#!/bin/bash
#
# Rebuild a pyramidal TIFF/WSI from a DeepZoom (.dzi) pyramid generated by run_vips.
# Usage: ./reconstruct_from_dzi.sh tiles/sample.dzi output/sample_rebuild.tif
#
# Requirements:
#   - bash, python (for simple XML parsing), and libvips CLI (`vips`)
#   - Sufficient temporary disk space (rows are buffered as .v intermediates)
#
# The script crops each tile to remove overlap borders, stitches rows with `vips join`,
# then joins rows vertically and finally writes a tiled pyramid TIFF via `vips tiffsave`.

set -euo pipefail

if [ $# -lt 2 ]; then
  echo "Usage: $0 <path/to/slide.dzi> <output.tif>" >&2
  exit 1
fi

if ! command -v vips >/dev/null 2>&1; then
  echo "Error: libvips CLI ('vips') not found in PATH." >&2
  exit 1
fi

if command -v python3 >/dev/null 2>&1; then
  PYTHON=python3
elif command -v python >/dev/null 2>&1; then
  PYTHON=python
else
  echo "Error: python interpreter not found (needed for parsing .dzi metadata)." >&2
  exit 1
fi

if command -v realpath >/dev/null 2>&1; then
  dzi_path=$(realpath "$1")
else
  dzi_path=$(
    "$PYTHON" - "$1" <<'PY'
import os, sys
print(os.path.abspath(sys.argv[1]))
PY
  )
fi
output_path="$2"
output_dir=$(dirname "$output_path")
[ -d "$output_dir" ] || mkdir -p "$output_dir"

if [ ! -f "$dzi_path" ]; then
  echo "Error: '$dzi_path' does not exist." >&2
  exit 1
fi

read -r dzi_width dzi_height tile_size overlap tile_format < <(
  "$PYTHON" - "$dzi_path" <<'PY'
import sys
import xml.etree.ElementTree as ET

path = sys.argv[1]
root = ET.parse(path).getroot()
ns = {'dz': 'http://schemas.microsoft.com/deepzoom/2008'}
size = root.find('{http://schemas.microsoft.com/deepzoom/2008}Size')
tile_size = int(root.attrib['TileSize'])
overlap = int(root.attrib['Overlap'])
fmt = root.attrib.get('Format', 'jpg').lower()
width = int(size.attrib['Width'])
height = int(size.attrib['Height'])
print(width, height, tile_size, overlap, fmt)
PY
)

tile_root="${dzi_path%.dzi}_files"
if [ ! -d "$tile_root" ]; then
  echo "Error: tile directory '$tile_root' not found (expected run_vips layout)." >&2
  exit 1
fi

max_level=$(ls "$tile_root" | grep -E '^[0-9]+$' | sort -n | tail -n1 || true)
if [ -z "$max_level" ]; then
  echo "Error: could not locate level folders inside '$tile_root'." >&2
  exit 1
fi

level_dir="$tile_root/$max_level"
ext=".$tile_format"

cols=$(( (dzi_width + tile_size - 1) / tile_size ))
rows=$(( (dzi_height + tile_size - 1) / tile_size ))

tmpdir=$(mktemp -d 2>/dev/null || mktemp -d -t dzi_rebuild)
cleanup() {
  rm -rf "$tmpdir"
}
trap cleanup EXIT

make_tmp_image() {
  local label=$1
  local base
  base=$(mktemp "$tmpdir/${label}_XXXXXX")
  local path="${base}.v"
  mv "$base" "$path"
  echo "$path"
}

echo "Rebuilding from $dzi_path"
echo "  Base resolution: ${dzi_width} x ${dzi_height}"
echo "  Tile size: ${tile_size}, overlap: ${overlap}, level: ${max_level}"
echo "  Tile grid: ${cols} columns x ${rows} rows"

build_row() {
  local row=$1
  local current=""

  for ((col=0; col<cols; col++)); do
    local tile="$level_dir/${col}_${row}${ext}"
    if [ ! -f "$tile" ]; then
      echo "Missing tile $tile" >&2
      exit 1
    fi

    local dims
    IFS=$'\n' read -r -d '' -a dims < <(vipsheader -f width -f height "$tile" && printf '\0')
    local tile_w=${dims[0]}
    local tile_h=${dims[1]}

    local left_trim=$overlap
    local right_trim=$overlap
    local top_trim=$overlap
    local bottom_trim=$overlap

    (( col == 0 )) && left_trim=0
    (( col == cols - 1 )) && right_trim=0
    (( row == 0 )) && top_trim=0
    (( row == rows - 1 )) && bottom_trim=0

    local crop_w=$(( tile_w - left_trim - right_trim ))
    local crop_h=$(( tile_h - top_trim - bottom_trim ))
    if (( crop_w <= 0 || crop_h <= 0 )); then
      echo "Computed non-positive crop (${crop_w} x ${crop_h}) for tile $tile" >&2
      exit 1
    fi

    local cropped
    cropped=$(make_tmp_image "tile_${row}_${col}")
    vips extract_area "$tile" "$cropped" "$left_trim" "$top_trim" "$crop_w" "$crop_h"

    if [ -z "$current" ]; then
      current="$cropped"
    else
      local next
      next=$(make_tmp_image "row_${row}")
      vips join "$current" "$cropped" "$next" horizontal --align=low --expand
      rm -f "$current" "$cropped"
      current="$next"
    fi
  done

  if [ -z "$current" ]; then
    echo "Row $row produced no data." >&2
    exit 1
  fi

  echo "$current"
}

mosaic=""
for ((row=0; row<rows; row++)); do
  echo "  Stitching row $((row + 1)) / $rows ..."
  row_img=$(build_row "$row")

  if [ -z "$mosaic" ]; then
    mosaic="$row_img"
  else
    next=$(make_tmp_image "mosaic_${row}")
    vips join "$mosaic" "$row_img" "$next" vertical --align=low --expand
    rm -f "$mosaic" "$row_img"
    mosaic="$next"
  fi
done

echo "Writing pyramidal TIFF to $output_path"
vips tiffsave "$mosaic" "$output_path" \
  --tile --pyramid --compression jpeg --Q 90 \
  --tile-width "$tile_size" --tile-height "$tile_size" \
  --bigtiff

echo "Done."
